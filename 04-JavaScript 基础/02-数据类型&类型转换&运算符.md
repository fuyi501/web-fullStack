# 数据类型&类型转换&运算符

## 内置类型

JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。

基本类型有六种： `null，undefined，boolean，number，string，symbol`。

其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。NaN 也属于 number 类型，并且 NaN 不等于自身。

对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型

```js
let a = 111 // 这只是字面量，不是 number 类型
a.toString() // 使用时候才会转换为对象类型
```

JS中的字符串需要使用引号引起来，双引号或单引号都行。

JS中所有的`整数和浮点数`都是 `Number` 类型。

特殊的数字：`Infinity`为正无穷，`-Infinity`为负无穷，`NaN` 为非法数字（Not A Number）。

其他进制的数字的表示：
* 0b 开头表示二进制，但是不是所有的浏览器都支持
* 0 开头表示八进制
* 0x 开头表示十六进制

注意事项：

1. 在JS中，字符串需要使用引号引起来。使用双引号或单引号都可以，但是不要混着用。
2. 引号不能嵌套：双引号里不能再放双引号，单引号里不能再放单引号。但是单引号里可以嵌套双引号。

3. 转义字符：在字符串中我们可以使用 `\` 作为转义字符，当表示一些特殊符号时可以使用 `\` 进行转义。

* `\"` 表示 `"`
* `\'` 表示 `'`
* `\n` 表示 `换行`
* `\r` 表示 `回车`
* `\t` 表示 `制表符`
* `\b` 表示 `空格`
* `\\` 表示 `\`

### null 和 undefined

#### null：空值

专门用来表示一个为空的对象（例如：var a = null）。注意，专门用来表示**空对象**。

Null 类型的值只有一个，就是 null。比如：var a = null。

使用 typeof 检查一个 null 值时，会返回 object。

#### undefined：未定义

声明了一个变量，但是没有赋值（例如：var a;），此时它的值就是 undefined。

Undefined 类型的值只有一个，就是 undefined

使用 type of 检查一个 undefined 时，会返回 undefined。

null和undefined有最大的相似性。看看 null == undefined 的结果(true)也就更加能说明这点。

但是 null === undefined 的结果(false)。它们虽然相似，但还是有区别的，
其中一个区别是：和数字运算时，10 + null结果为：10；10 + undefined结果为：NaN。

**任何数据类型和undefined运算都是NaN;**

**任何值和null运算，null可看做0运算。**

## 类型转换

类型转换就是指将其他的数据类型，转换为 `String` `Number` 或 `Boolean`

### 转换为 String：

转换成 `String` 有三种方法 ，分别是 `调用 toString()方法` ，`调用 String()函数` 和 `任意的数据类型 + ""`。

`调用 toString()方法` 和 `调用 String() 函数` 属于强制类型转换，`任意的数据类型 + ""` 为隐式的类型转换。

调用 `toString()方法` 不适用于 `null` 和 `undefined`，因为这两个类型的数据中没有方法，所以调用 toString() 时会报错。

调用 `String()函数` 的原理：对于 `Number Boolean String` 都会调用他们的 `toString()方法` 来将其转换为字符串，对于 `null` 值，直接转换为字符串 `"null"`。对于 `undefined` 直接转换为字符串 `"undefined"`。

`任意的数据类型 + ""` 的原理与调用 `String()函数` 的原理一样。

### 转换为 Number

转换成 `Number` 也有三种方法 ，分别是 `调用 Number() 函数` ，`调用 parseInt() 或 parseFloat()` 和 `使用一元的 + 来进行隐式的类型转换`。

调用 Number()函数 的情况有四种：

1. 字符串 --> 数字
  - 如果字符串是一个合法的数字，则直接转换为 `对应的数字`
  - 如果字符串是一个非法的数字，则转换为 `NaN`
  - 如果是一个空串或纯空格的字符串，则转换为 `0`
2. 布尔值 --> 数字
  - true 转换为 `1`
  - false 转换为 `0`
3. 空值 --> 数字
  - null 转换为 `0`
4. 未定义 --> 数字
  - undefined 转换为 `NaN`

parseInt() 或 parseFloat() 这两个函数是专门用来将一个字符串转换为数字的。

parseInt() 可以将一个字符串中的有效的整数位提取出来，并转换为Number，比如：

```js
var a = "123.456px";
a = parseInt(a); // 123
```
可以在 parseInt() 中指定第二个参数，来指定采用哪种进制转换。

parseFloat() 可以将一个字符串中的有效的小数位提取出来，并转换为Number ，比如：

```js
var a = "123.456px";
a = parseFloat(a); // 123.456
```

使用一元的 + 可以进行隐式的类型转换，其原理和Number()函数一样，比如：

```js
var a = "123";
a = +a;
console.log(1 + +'2') // 3, 先计算 +‘2’ 为 数字 2
```

### 转换为布尔值

转换为 布尔值 有两种方法：
1. 使用 Boolean()函数
2. 为任意的数据类型做两次非运算，即可将其转换为布尔值

使用 Boolean()函数的情况有四种：

1. 字符串 --> 布尔
  - 除了空串其余全是true
2. 数值 --> 布尔
  - 除了0和NaN其余的全是true
3. null、undefined ---> 布尔
  - 都是false
4. 对象 ---> 布尔
  - 都是true，即便是 空数组[], 空对象{}

为任意的数据类型做两次非运算，可将其转换为布尔值，比如：

```js
var a = "hello";
a = !!a; // true
```

## 运算符

运算符也称为操作符，通过运算符可以对一个或多个值进行 运算或操作。

### typeof运算符

用来检查一个变量的数据类型，语法：`typeof 变量`，它会返回一个用于描述类型的 `字符串` 作为结果，且是小写。

**返回结果：**

`typeof` 对于基本类型，除了 `null` 都可以显示正确的类型。

```js
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof b // b 没有声明，但是还会显示 undefined
```

`typeof` 对于对象，除了函数都会显示 `object`。

```js
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```

对于 `null` 来说，虽然它是基本类型，但是会显示 `object`，这是一个存在很久了的 `Bug`

```js
typeof null // 'object'
```

PS：为什么会出现这种情况呢？因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，`000` 开头代表是对象，然而 `null` 表示为全零，所以将它错误的判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 `Bug` 却是一直流传下来。

如果我们想获得一个变量的正确类型，可以通过 `Object.prototype.toString.call(xx)`。这样我们就可以获得类似 `[object Type]` 的字符串。

```
console.log(Object.prototype.toString.call(null)) // [object null]
```

```js
let a
// 我们也可以这样判断 undefined
a === undefined
// 但是 undefined 不是保留字，能够在低版本浏览器被赋值
let undefined = 1
// 这样判断就会出错
// 所以可以用下面的方式来判断，并且代码量更少
// 因为 void 后面随便跟上一个组成表达式
// 返回就是 undefined
a === void 0
```

**void 后面随便跟上一个组成表达式，返回就是 undefined**

在JavaScript中，只要是数，就是 `number` 数值型的。无论整浮、浮点数（即小数）、无论大小、无论正负，都是 `number` 类型的。

**注意：** `typeof NaN` 的返回结果是 `number`。

### 算数运算符

加减乘除求余：`+ - * / %`

**除了加法以外，对非 `Number` 类型的值进行运算时，都会先转换为 `Number` 然后在做运算。**

**做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。**

**任何值和字符串做加法，都会先转换为字符串，然后再拼串。**

### 一元运算符

一元运算符只需要一个操作数。

#### 一元的 +

就是正号，不会对值产生任何影响，但是**可以将一个非数字转换为数字**，比如：

```js
var a = true;
a = +a;
```

#### 一元的 -

就是负号，可以对一个数字进行符号位取反。

#### 自增

自增可以使变量在原值的基础上 `自增 1`，自增使用 `++` ， 自增可以使用 `前++（++a）和 后++(a++)`。

无论是 `++a` 还是 `a++` 都会立即使原变量自增1，不同的是 `++a` 和 `a++` 本身的值是不同的，**`++a` 的值是变量的新值（自增后的值）**，**`a++` 的值是变量的原值（自增前的值）**。

```js
// 例子
var a = 10;
console.log(a++ + ++a + a) // 34
```

#### 自减

自减可以使变量在原值的基础上 `自减 1`，自减使用 `--`，自减可以使用 `前--（--a）和 后--(a--)`。

无论是 `--a` 还是 `a--` 都会立即使原变量自减1，不同的是 `--a` 和 `a--` 的值是不同的，**`--a` 的值是变量的新值（自减后的值）**，**`a--` 的值是变量的原值（自减前的值）**，这个和 **`自增`** 是一样的。

### 逻辑运算符

与或非：`! && ||`

### 赋值运算符

`= += -= /= *= %=`

### 关系运算符

`> >= < <=`

关系运算符用来比较两个值之间的大小关系的，关系运算符的规则和数学中一致，用来比较两个值之间的关系，如果关系成立则返回true，关系不成立则返回false。

**如果比较的两个值是非数值，会将其转换为 `Number` 然后再比较。也就是说关系运算符最后比较的值两边都是 `Number`**

**如果比较的两个值都是字符串，此时会比较字符串的 `Unicode` 编码，而不会转换为 `Number`。**

### 相等运算符

#### 相等 ==

1. 如果两个值类型相同，进行 === 比较。
2. 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：
* 如果一个是 null、一个是 undefined，那么 [相等];
* 如果任一值是字符串，另一个值是数值，在比较相等性之前先将字符串转换为数值，即调用 `Number()` 函数。
* 如果任一值时布尔值，则在比较相等性之前先将其转换为数值，即调用`Number()` 函数。
* 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的 `toString()` 或者 `valueOf()` 方法。 js 核心内置类，会尝试 `valueOf()` 先于 `toString()`；例外的是 Date，Date 利用的是 toString 转换。

**记住：对象永远先转成 字符串再比较。**

#### 不等 !=

判断左右两个值是否不等，如果不等则返回true，如果相等则返回false，不等也会做自动的类型转换。

#### 全等 === (严格运算符)

1. 如果类型不同，就 [不相等]
2. 如果两个都是数值，并且是同一个值，那么 [相等]；如果其中至少一个是 NaN，那么 [不相等]。（判断一个值是否是 NaN，只能用 isNaN() 来判断）
3. 如果两个都是字符串，每个位置的字符都一样，那么 [相等]；否则 [不相等]。
4. 如果两个值都是 true，或者都是 false，那么 [相等]。
5. 如果两个值都引用同一个对象或函数，那么 [相等]；否则 [不相等]。
6. 如果两个值都是 null，或者都是 undefined，那么 [相等]。

#### 不全等 !==

和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回 true。

这里来解析一道题目 `[] == ![] // -> true` ，下面是这个表达式为何为 `true` 的步骤:

1. 首先 `![ ]` 这个是要对空数组转成布尔类型结果得到 `![ ] = false`;
2. `[ ]` 为对像，所以使用对象的 `toString()` 方法，也就是 `[].toString()`，结果为 空字符串 `“”`;
3. 只要**记住关系运算符和相等运算符最后比较的两边的值都为 Number 就可以**;
4. 两边类型不同都转换成 `Number`，`Number(“”)`为 `0` ，`Number(false)` 为 `0`，所以最后就是比较 `0 == 0` ，两个同时为数值类型且都为 `0` ，所以比较结果为 `true`。

一些特殊的值：

null 和 undefined，由于 undefined 衍生自 null，所以 `null == undefined` 会返回 true，`null === undefined` 会返回 false。

NaN不与任何值相等，包括它自身 `NaN == NaN // false`

判断一个值是否是 `NaN`，使用 `isNaN()` 函数

### 三元运算符

`?:`

## 其他

### 变量的命名规则：

1. 建议用驼峰命名规则：getElementById/matherAndFather/aaaOrBbbAndCcc

2. 变量命名必须以字母或是下标符号”_”或者”$”为开头。

3. 变量名长度不能超过255个字符。

4. 变量名中不允许使用空格，首个字不能为数字。

5. 不用使用脚本语言中保留的关键字及保留字作为变量名。

6. 变量名区分大小写(javascript是区分大小写的语言)。

7. 汉语可以作为变量名。但是不建议使用，因为 low。
