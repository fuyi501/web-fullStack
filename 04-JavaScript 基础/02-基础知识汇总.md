
## 内置类型

JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。

基本类型有六种： `null，undefined，boolean，number，string，symbol。`

其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。NaN 也属于 number 类型，并且 NaN 不等于自身。

- JS中的字符串需要使用引号引起来，双引号或单引号都行
- JS中所有的整数和浮点数都是Number类型
- 特殊的数字
  * Infinity 正无穷
  * -Infinity 负无穷
  * NaN 非法数字（Not A Number）
- 其他进制的数字的表示：
	* 0b 开头表示二进制，但是不是所有的浏览器都支持
	* 0 开头表示八进制
	* 0x 开头表示十六进制

## 类型转换
类型转换就是指将其他的数据类型，转换为String Number 或 Boolean
- 转换为String
  - 方式一（强制类型转换）：
    - 调用被转换数据的toString()方法
    - 例子：
      var a = 123;
      a = a.toString();
    - 注意：这个方法不适用于null和undefined
      由于这两个类型的数据中没有方法，所以调用toString()时会报错
					
  - 方式二（强制类型转换）：
    - 调用String()函数
    - 例子：
      var a = 123;
      a = String(a);
    - 原理：对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串"null"。对于undefined直接转换为字符串"undefined"
					
  - 方式三（隐式的类型转换）: 
    - 为任意的数据类型 + ""
    - 例子：
      var a = true;
      a = a + "";
    - 原理：和String()函数一样	
				
- 转换为 Number
  - 方式一（强制类型转换）：
    - 调用Number()函数
    - 例子：
      var s = "123";
      s = Number(s);
    - 转换的情况：
      1. 字符串 --> 数字
        - 如果字符串是一个合法的数字，则直接转换为对应的数字
        - 如果字符串是一个非法的数字，则转换为NaN
        - 如果是一个空串或纯空格的字符串，则转换为0
      2. 布尔值 --> 数字
        - true转换为1
        - false转换为0
      3. 空值 --> 数字
        - null转换为0
      4. 未定义 --> 数字
        - undefined 转换为NaN
        
  - 方式二（强制类型转换）：
    - 调用 parseInt() 或 parseFloat()
    - 这两个函数专门用来将一个字符串转换为数字的
    - parseInt()
      - 可以将一个字符串中的有效的整数位提取出来，并转换为Number
      - 例子：
        var a = "123.456px";
        a = parseInt(a); //123
      - 如果需要可以在parseInt()中指定一个第二个参数，来指定进制	
        
    - parseFloat()
      - 可以将一个字符串中的有效的小数位提取出来，并转换为Number
      - 例子：
        var a = "123.456px";
        a = parseFloat(a); //123.456
        
  - 方式三（隐式的类型转换）：
    - 使用一元的+来进行隐式的类型转换
    - 例子：
      var a = "123";
      a = +a;
    - 原理：和Number()函数一样	
    
- 转换为布尔值
  - 方式一（强制类型转换）：
    - 使用Boolean()函数
    - 例子：
      var s = "false";
      s = Boolean(s); //true
    - 转换的情况
      1. 字符串 --> 布尔
        - 除了空串其余全是true
      2. 数值 --> 布尔
        - 除了0和NaN其余的全是true
      3. null、undefined ---> 布尔
        - 都是false
      4. 对象 ---> 布尔
        - 都是true
  - 方式二（隐式类型转换）：	
    - 为任意的数据类型做两次非运算，即可将其转换为布尔值
    - 例子：	
      var a = "hello";
      a = !!a; //true
				
## 运算符

- 运算符也称为操作符
- 通过运算符可以对一个或多个值进行运算或操作

- typeof运算符
  - 用来检查一个变量的数据类型
  - 语法：typeof 变量
  - 它会返回一个用于描述类型的字符串作为结果
  
- 算数运算符
  +	对两个值进行加法运算并返回结果
  - 对两个值进行减法运算并返回结果
  *	对两个值进行乘法运算并返回结果
  /	对两个值进行除法运算并返回结果
  %	对两个值进行取余运算并返回结果
  
  - **除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。**
  - **而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。**
  - **任何值和字符串做加法，都会先转换为字符串，然后再拼串**

- 一元运算符
  - 一元运算符只需要一个操作数
  - 一元的 + 
    - 就是正号，不会对值产生任何影响，但是**可以将一个非数字转换为数字**
    - 例子：
      var a = true;
      a = +a;
				
  - 一元的 -
    - 就是负号，可以对一个数字进行符号位取反
    - 例子：
      var a = 10;
      a = -a;
      
  - 自增
    - 自增可以使变量在原值的基础上自增1
    - 自增使用 ++
    - 自增可以使用 前++（++a）后++(a++)
    - 无论是++a 还是 a++都会立即使原变量自增1
      不同的是++a和a++的值是不同的，
      ++a的值是变量的新值（自增后的值）
      a++的值是变量的原值（自增前的值）

  - 自减	
    - 自减可以使变量在原值的基础上自减1
    - 自减使用 --
    - 自减可以使用 前--（--a）后--(a--)
    - 无论是--a 还是 a--都会立即使原变量自减1
      不同的是--a和a--的值是不同的，
      --a的值是变量的新值（自减后的值）
      a--的值是变量的原值（自减前的值）

* 逻辑运算符: `! && ||`

* 赋值运算符: `= += -= /= */ %/`

* 关系运算符: `> >= < <=`
  - 关系运算符用来比较两个值之间的大小关系的
  - 关系运算符的规则和数学中一致，用来比较两个值之间的关系，如果关系成立则返回true，关系不成立则返回false。
  - 如果比较的两个值是非数值，会将其转换为Number然后再比较。
  - 如果比较的两个值都是字符串，此时会比较字符串的Unicode编码，而不会转换为Number。

* 相等运算符
  * ==
    - 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false
    - 相等会自动对两个值进行类型转换，如果对不同的类型进行比较，会将其转换为相同的类型然后再比较，
      转换后相等它也会返回true
  * !=
    - 不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false
    - 不等也会做自动的类型转换。
    
  * ===
    - 全等，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，如果两个值的类型不同，则直接返回false
      
  * !==
    - 不全等，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true

这里来解析一道题目 `[] == ![] // -> true` ，下面是这个表达式为何为 `true` 的步骤:

`===` 叫做严格运算符，`==` 叫做相等运算符。

严格运算符的运算规则如下：

1、如果类型不同，就[不相等] 
2、如果两个都是数值，并且是同一个值，那么[相等]；如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断） 
3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。 
4、如果两个值都是true，或者都是false，那么[相等]。 
5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。 
6、如果两个值都是null，或者都是undefined，那么[相等]。

相等运算符的运算规则如下： 

1、如果两个值类型相同，进行 === 比较。 
2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： 
（1）如果一个是null、一个是undefined，那么[相等]。 
（2）如果任一值是字符串，另一个值是数值，在比较相等性之前先将字符串转换为数值；即是调用Number()函数。 
（3）如果任一值时布尔值，则在比较相等性之前先将其转换为数值，即是调用Number()函数。 
（4）如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 js核心内置类，会尝试 valueOf 先于 toString；例外的是Date，Date 利用的是 toString 转换。

再次分析 `[] == ![]` 这道题：
(1）看见 ![ ]这个是要对空数组转成布尔类型结果得到![ ] = false,(2) 发现此时符合第三条，如果任一值是布尔类型是需要将其转换为数值，即Number(false),结果为 Number(false) = 0。
(3) 此时得到 [ ] == 0 比较，此时符合第四条即 [ ].toString()；结果为[].toString() = ” ”;
(4) 此时得到 ” ” == 0,发现符合第二条即Number(“”)； 
结果为Number(” ”) = 0;
(5) 此时得到 0 == 0 两个同时为数值类型比较所以结果为true;

特殊的值：
  - null和undefined
    - 由于undefined衍生自null，所以null == undefined 会返回true。
    但是 null === undefined 会返回false。
      
  - NaN
    - NaN不与任何值相等，包括它自身 NaN == NaN //false
    
  - 判断一个值是否是NaN
    - 使用isNaN()函数

* 三元运算符：?:


			

		
		
		
		
		
		
		
		
		