# 五、计算字段与数据处理函数

## 1. 计算字段

存储在数据库表中的数据一般不是应用程序所需要的格式。下面举几个例子。

* 如果想在一个字段中既显示公司名，又显示公司的地址，但这两个信息一般包含在不同的表列中。
* 城市、州和邮政编码存储在不同的列中（应该这样） ，但邮件标签打印程序却需要把它们作为一个恰当格式的字段检索出来。
* 列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来。
* 物品订单表存储物品的价格和数量，但不需要存储每个物品的总价格（用价格乘以数量即可） 。为打印发票，需要物品的总价格。
* 需要根据表数据进行总数、平均数计算或其他计算。

在上述每个例子中，存储在表中的数据都不是应用程序所需要的。
我们需要直接从数据库中检索出转换、计算或格式化过的数据；而不是检索出数据，然后再在客户机应用程序或报告程序中重新格式化。

:::tip 字段
基本上与列的意思相同，经常互换使用，不过数据库一般称为列，而术语**字段**通常用在计算字段的连接上。
:::

### 拼接字段

**拼接：** 将值联结到一起构成单个值。

在SELECT语句中，可使用`Concat()`函数来拼接两个列。`Concat()`函数需要一个或多个指定的串，各个串之间用逗号分隔。

```sql
SELECT Concat(vend_name, ' (',vend_country,')')
FROM vendors
ORDER BY vend_name;

# output
+-----------------------------------------+
| Concat(vendname,' (',vend_country,')') |
+-----------------------------------------+
| ACME (USA)                              |
| Anvils R Us (USA)                       |
| Furball Inc. (USA)                      |
| Jet Set (England)                       |
| Jouets Et Ours (France)                 |
| LT Supplies (USA)                       |
+-----------------------------------------+
```

使用 RTrim()函数可以删除右侧多余的空格来整理数据，例：

```sql
SELECT Concat(RTrim(vend_name),' (',RTrim(vend_country), ')')
FROM vendors
ORDER BY vend_name;
```

| 函数 | 说明 |
|-----|------|
|Trim()|去掉两边的空格|
|LTrim()|去掉左边的空格|
|RTrim()|去掉右边的空格|

### 使用别名

拼接的结果只是一个值，未命名。可以用`AS`关键字赋予别名。

常见的用途包括在实际的表列名包含不符合规定的字符(如空格)时重新命名它，在原来的名字含混或容易误解时扩充它等等。

**别名有时也称为导出列（derived column）。**

```sql
SELECT Concat(RTrim(vend_name),' (',RTrim(vend_country), ')') AS vend_title
FROM vendors
ORDER BY vend_name;

# output
+----------------------------+
| vend_name                  |
+----------------------------+
| ACME (USA)                 |
| Anvils R Us (USA)          |
| Furball Inc. (USA)         |
| Jet Set (England)          |
| Jouets Et Ours (France)    |
| LT Supplies (USA)          |
+----------------------------+
#指示SQL创建一个包含指定计算的名为vend_title的计算字段
```

### 执行算术计算

计算字段的另一常见用途是对检索出的数据进行算术计算。

例如：汇总物品的价格（单价乘以订购数量）

```sql
SELECT prod_id,
    quantity,
    item_price,
    quantity * item_price AS expanded_price
FROM orderitems
WHERE order_num = 20005;

#output
+---------+----------+------------+----------------+
| prod_id | quantity | item_price | expanded_price |
+---------+----------+------------+----------------+
| ANV01   |       10 |       5.99 |          59.90 |
| ANV02   |        3 |       9.99 |          29.97 |
| TNT2    |        5 |      10.00 |          50.00 |
| FB      |        1 |      10.00 |          10.00 |
+---------+----------+------------+----------------+
```

| 操作符 | 说明 |
|------|----|
| + | 加 |
| - | 减 |
| * | 乘 |
| / | 除 |

SELECT Now() 利用 Now()函数返回当前日期和时间

## 2. 使用数据处理函数

与其他大多数计算机语言一样， SQL支持利用函数来处理数据。 函数一般是在数据上执行的，它给数据的转换和处理提供了方便。

### 使用函数

大多数SQL实现支持以下类型的函数：

- 用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。
- 用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数。
- 用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等）的日期和时间函数。
- 返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。

### 文本处理函数

**常用的文本处理函数：**

| 函数 | 说明 |
|-----|-----|
| Left() | 返回串左边的字符 |
| Length() | 返回串的长度 |
| Locate() | 找出串的一个子串 |
| Lower() | 将串转换为小写 |
| LTrim() | 去掉串左边的空格 |
| Right() | 返回串右边的字符 |
| RTrim() | 去掉串右边的空格 |
| Soundex() | 返回串的SOUNDEX值 |
| SubString() | 返回子串的字符 |
| Upper() | 将串转换为大写 |

表中的SOUNDEX需要做进一步的解释。SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。 SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。（了解）

下面给出一个使用Soundex()函数的例子。

例：联系人Y.Lie输入错误为Y.Lee，使用SOUNDEX检索，匹配发音类似于Y.Lie的联系名。

```sql
SELECT cust_name, cust_contact FROM customers
WHERE Soundex(cust_contact）= Soundex('Y Lie');
#output
+-------------+--------------+
| cust_name   | cust_contact |
+-------------+--------------+
| Coyote Inc. | Y Lee        |
+-------------+--------------+
```

### 日期和时间处理函数

**常用日期和时间处理函数：**

| 函数 | 说明 |
|-----|-----|
|AddDate()|增加一个日期（天、周等）|
|AddTime()|增加一个时间（时、分等）|
|CurDate()|返回当前日期|
|CurTime()|返回当前时间|
|Date()|返回日期时间的日期部分|
|DateDiff()|计算两个日期之差|
|Date_Add()|高度灵活的日期计算函数|
|Date_Format()|返回一个格式化的日期或时间串|
|Day()|返回一个日期的天数部分|
|DayOfWeek()|对于一个日期，返回对应的星期几|
|Hour()|返回一个时间的小时部分|
|Minute()|返回一个时间的分钟部分|
|Month()|返回一个日期的月份部分|
|Now()|返回当前日期和时间|
|Second()|返回一个时间的秒部分|
|Time()|返回一个日期时间的时间部分|
|Year()|返回一个日期的年份部分|

:::tip 注意
首先需要注意的是MySQL使用的日期格式。无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。
:::

:::warning 应该总是使用4位数字的年份
支持2位数字的年份，MySQL 处理00-69为2000-2069，处理70-99为1970-1999。虽然它们可能是打算要的年份，但使用完整的4位数字年份更可靠，因为MySQL不必做出任何假定。
:::


```sql
SELECT cust_id, order_num
FROM orders
WHERE order_date = '2005-09-01';
```

但是，使用`WHERE order_date = '2005-09-01'`可靠吗？order_date的数据类型为datetime。这种类型存储日期及时间值。样例表中的值全都具有时间值00:00:00，但实际中很可能并不总是这样。如果用当前日期和时间存储订单日期（因此你不仅知道订单日期，还知道下订单当天的时间），怎么办？比如，存储的 order_date 值为2005-09-01 11:30:05，则WHERE order_date = '2005-09-01' 失败。即使给出具有该日期的一行，也不会把它检索出来，因为WHERE匹配失败。

解决办法是指示MySQL仅将给出的日期与列中的日期部分进行比较，而不是将给出的日期与整个列值进行比较。为此，必须使用Date() 函数。Date(order_date)指示MySQL仅提取列的日期部分，更可靠的SELECT语句为：

```sql
SELECT cust_id, order_num
FROM orders
WHERE Date(order_date) = '2005-09-01';
```

:::tip 如果要的是日期，请使用Date()
如果你想要的仅是日期，则使用Date()是一个良好的习惯，即使你知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个Time()函数，在你只想要时间时应该使用它。
:::

如果你想检索出2005年9月下的所有订单，怎么办？简单的相等测试不行，因为它也要匹配月份中的天数。
有几种解决办法，如下所示：

```sql
SELECT cust_id, order_num FROM orders
WHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';
-- BETWEEN把2005-09-01和2005-09-30定义为一个要匹配的日期范围。
-- 另一种方法
SELECT cust_id, order_num FROM orders
WHERE Year(roder_date) = 2005 AND Month(order_date) = 9;
```

### 数值处理函数

| 函数 | 说明 |
|---|---|
|Abs()|返回一个数的绝对值|
|Cos()|返回一个角度的余弦|
|Exp()|返回一个数的指数值|
|Mod()|返回除操作的余数|
|Pi() |返回圆周率|
|Rand()|返回一个随机数|
|Sin()|返回一个角度的正弦|
|Sqrt()|返回一个数的平方根|
|Tan()|返回一个角度的正切|
