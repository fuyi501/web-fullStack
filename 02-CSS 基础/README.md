
## CSS 样式

- 内部样式表

```html
<!--
  可以将CSS样式编写到head中的style标签里
  将样式表编写的style标签中，然后通过CSS选择器选中指定元素
  然后可以同时为这些元素一起设置样式，这样可以使样式进一步的复用
  将样式表编写到style标签中，也可以使表现和结构进一步分离它也是我们推荐的使用方式
-->

<style type="text/css">
p{
    color:red;
    font-size:40px;
}
</style>
```

- 外部样式表

```html
<!--
  还可以将样式表编写到外部的CSS文件中,然后通过link标签来将外部的CSS文件引入到当前页面中，
  这样外部文件中的css样式表将会应用到当前页面中。

  将CSS样式统一编写到外部的样式表中，完全使结构和表现分离，可以是样式表可以在不同的页面中使用，
  最大限度的使样式可以进行复用，将样式统一写在样式表中，然后通过link标签引入，可以利用浏览器的缓存
  加快用户访问的速度提高了用户体验，所以在开发中我们最推荐使用的方式就是外部的CSS文件
-->
<link rel="stylesheet" type="text/css" href="style.css" />
```

- 内联样式

```html
<!--
  可以将CSS样式编写到元素的style属性当中
  将样式直接编写到style属性中，这种样式我们称为内联样式
  内联样式只对当前的元素中的内容起作用，内联样式不方便复用
  内联样式属于结构与表现耦合，不方便后期的维护，不推荐使用的
-->
<p style="color:red;font-size:40px;">锄禾日当午，汗滴禾下土</p>
<p style="color:red;font-size:40px;">谁知盘中餐，粒粒皆辛苦</p>

```

- CSS的语法：选择器 声明块
  - 选择器：通过选择器可以选中页面中指定的元素，并且将声明块中的样式应用到选择器对应的元素上

  - 声明块：声明块紧跟在选择器的后边，使用一对{}括起来，声明块中实际上就是一组一组的键值对结构，这一组一组的键值对我们称为声明，在一个声明块中可以写多个声明，多个声明之间使用`;`隔开，声明的样式名和样式值之间使用`:`来连接

## 常用选择器

1. 元素选择器
   - 作用：通过元素选择器可以选则页面中的所有指定元素
   - 语法：标签名 {}
2. id选择器
   - 通过元素的id属性值选中唯一的一个元素
   - 语法：#id属性值 {}
3. 类选择器
   - 通过元素的class属性值选中一组元素
   - 语法：.class属性值 {}
4. 通配选择器
   - 他可以用来选中页面中的所有的元素
   - 语法：*{}
5. 选择器分组(并集选择器)
   - 通过选择器分组可以同时选中多个选择器对应的元素
   - 语法：选择器1,选择器2,选择器N{}
6. 复合选择器（交集选择器）
   - 作用：可以选中同时满足多个选择器的元素
   - 语法：选择器1选择器2选择器N {}
   - 对于id选择器来说，不建议使用复合选择器
7. 后代元素选择器
   - 作用：选中指定元素的指定后代元素
   - 语法：祖先元素 后代元素{}	
8. 子元素选择器
   - 作用：选中指定父元素的指定子元素
   - 语法：父元素 > 子元素

## 选择器之间的关系

元素之间的关系:
- 父元素：直接包含子元素的元素
- 子元素：直接被父元素包含的元素
- 祖先元素：直接或间接包含后代元素的元素，父元素也是祖先元素
- 后代元素：直接或间接被祖先元素包含的元素，子元素也是后代元素
- 兄弟元素：拥有相同父元素的元素叫做兄弟元素

## 伪类选择器

伪类专门用来表示元素的一种的特殊的状态，比如：访问过的超链接，比如普通的超链接，比如获取焦点的文本框。当我们需要为处在这些特殊状态的元素设置样式时，就可以使用伪类。

- a:link
- a:visited
- a:hover
- a:active

:hover和:active也可以为其他元素设置，
但是在IE6中，不支持对超链接以外的元素设置:hover和:active

- p:hover
- p:active

文本框获取焦点以后，修改背景颜色为黄色

- input:focus

为p标签中选中的内容使用样式，可以使用::selection伪类。

- 注意：这个伪类在火狐中需要采用另一种方式编写::-moz-selection
- 兼容火狐的 p::-moz-selection
- 兼容大部分浏览器的 p::selection

## 伪元素

使用伪元素来表示元素中的一些特殊的位置。

- p:first-letter
- p:first-line
- p:before
- p:after

## 属性选择器

作用：可以根据元素中的属性或属性值来选取指定元素

语法：
- [属性名] 选取含有指定属性的元素
- [属性名="属性值"] 选取含有指定属性值的元素
- [属性名^="属性值"] 选取属性值以指定内容开头的元素
- [属性名$="属性值"] 选取属性值以指定内容结尾的元素
- [属性名*="属性值"] 选取属性值以包含指定内容的元素

## 子元素选择器

- body > p:first-child
- p:last-child
- p:nth-child
- :first-of-type
- :last-of-type
- :nth-of-type

first-of-type和:first-child这些非常的类似，只不过child，是在所有的子元素中排列，而type，是在当前类型的子元素中排列。

## 兄弟元素选择器

后一个兄弟元素选择器
- 作用：可以选中一个元素后紧挨着的指定的兄弟元素
- 语法：前一个 + 后一个
- span + p

选中后边的所有兄弟元素
- 语法：前一个 ~ 后边所有
- span ~ p

## 否定伪类

- 作用：可以从已选中的元素中剔除出某些元素
- 语法：:not(选择器)
- p:not(.hello)

## 样式的继承

CSS中，祖先元素上的样式，也会被他的后代元素所继承，利用继承，可以将一些基本的样式设置给祖先元素，这样所有的后代元素将会自动继承这些样式。

但是并不是所有的样式都会被子元素所继承，比如：背景相关的样式，边框相关的样式，定位相关的等都不会被继承

## 选择器的优先级

当使用不同的选择器，选中同一个元素时并且设置不同的样式时，这时样式之间产生了冲突，最终到底采用哪个选择器定义的样式，由选择器的优先级（权重）决定，优先级高的优先显示。

优先级的规则：

1. 内联样式 ， 优先级  1000
2. id选择器，优先级   100
3. 类和伪类， 优先级   10
4. 元素选择器，优先级 1 
5. 通配* ，    优先级 0
6. 继承的样式，没有优先级

当选择器中包含多种选择器时，需要将多种选择器的优先级相加然后再比较，但是注意，**选择器优先级计算不会超过他的最大的数量级**，如果选择器的优先级一样，则使用靠后的样式。

并集选择器的优先级是单独计算，div , p , #p1 , .hello{}	

可以在样式的最后，添加一个!important，则此时该样式将会获得一个最高的优先级，将会优先于所有的样式显示甚至超过内联样式，但是在开发中尽量避免使用!important

## a标签的伪类

涉及到a的伪类一共有四个：
- :link
- :visited
- :hover
- :active

而这四个选择器的优先级是一样的，顺序要按照上面的顺序来写。

## 字体的样式

1. font-style可以用来设置文字的斜体，可选值：
- normal，默认值，文字正常显示
- italic 文字会以斜体显示
- oblique 文字会以倾斜的效果显示

大部分浏览器都不会对倾斜和斜体做区分，也就是说我们设置italic和oblique它们的效果往往是一样的，一般我们只会使用italic。

2. font-weight可以用来设置文本的加粗效果，可选值：
- normal，默认值，文字正常显示
- bold，文字加粗显示

3. font-variant可以用来设置小型大写字母，可选值：
- normal，默认值，文字正常显示
- small-caps 文本以小型大写字母显示

小型大写字母：将所有的字母都以大写形式显示，但是小写字母的大写，要比大写字母的大小小一些。

在CSS中还为我们提供了一个样式叫font，使用该样式可以同时设置字体相关的所有样式,可以将字体的样式的值，统一写在font样式中，不同的值之间使用空格隔开

使用font设置字体样式时，斜体 加粗 小大字母，没有顺序要求，甚至可写可不写，如果不写则使用默认值，但是要求文字的大小和字体必须写，而且字体必须是最后一个样式，大小必须是倒数第二个样式，实际上使用简写属性也会有一个比较好的性能。

```css
font: small-caps bold italic 60px "微软雅黑";
```

## 行高

对于**单行文本**来说，可以将行高设置为和父元素的高度一致，这样可以是单行文本在父元素中垂直居中，注意仅限于单行文本，多行文本不适用。

在font中也可以指定行高，在字体大小后可以添加/行高，来指定行高，该值是可选的，如果不指定则会使用默认值。

```css
font: 30px/50px "微软雅黑";
/* line-height: 50px; */
```

## 文本样式

1. text-transform可以用来设置文本的大小写，可选值：
- none 默认值，该怎么显示就怎么显示，不做任何处理
- capitalize 单词的首字母大写，通过空格来识别单词
- uppercase 所有的字母都大写
- lowercase 所有的字母都小写

2. text-decoration可以用来设置文本的修饰，可选值：
- none：默认值，不添加任何修饰，正常显示
- underline 为文本添加下划线
- overline 为文本添加上划线
- line-through 为文本添加删除线

```css
a {
  /*超链接会默认添加下划线，也就是超链接的text-decoration的默认值是underline
  如果需要去除超链接的下划线则需要将该样式设置为none
  */
  text-decoration: none;
}
```

3. letter-spacing 可以指定字符间距
4. word-spacing 可以设置单词之间的距离
5. text-align 用于设置文本的对齐方式，可选值：
- left 默认值，文本靠左对齐
- right，文本靠右对齐
- center，文本居中对齐
- justify，两端对齐，通过调整文本之间的空格的大小，来达到一个两端对齐的目的。

6. text-indent 用来设置首行缩进
- 当给它指定一个正值时，会自动向右侧缩进指定的像素
- 如果为它指定一个负值，则会向左移动指定的像素,通过这种方式可以将一些不想显示的文字隐藏起来
- 这个值一般都会使用em作为单位，`text-indent: 2em`; 

## 盒子模型

为元素设置边框，要为一个元素设置边框必须指定三个样式
- border-width:边框的宽度
- border-color:边框颜色
- border-style:边框的样式

设置边框的样式，可选值：
- none，默认值，没有边框
- solid 实线
- dotted 点状边框
- dashed 虚线
- double 双线

border：边框的简写样式，通过它可以同时设置四个边框的样式，宽度，颜色，而且没有任何的顺序要求，border一指定就是同时指定四个边不能分别指定。

border-top border-right border-bottom border-left 可以单独设置四个边的样式，规则和border一样，只不过它只对一个边生效。

```css
/* 设置三个边，取消一个边 */
border: red solid 10px;
border-right: none;
```

## 外边距 margin

margin 可以设置为auto，auto一般只设置给水平方向的margin
如果只指定左外边距或右外边距的margin为auto则会将外边距设置为最大值

垂直方向外边距如果设置为auto，则外边距默认就是0

如果将left和right同时设置为auto，则会将两侧的外边距设置为相同的值，就可以使元素自动在父元素中居中，所以我们经常将左右外边距设置为auto，以使子元素在父元素中水平居中。

外边距同样可以使用简写属性 margin，可以同时设置四个方向的外边距， 规则和padding一样。

```css
margin: 0 auto;
```

**垂直外边距的重叠**

在网页中相邻的垂直方向的外边距会发生外边距的重叠，

所谓的外边距重叠指**兄弟元素**之间的**相邻外边距**会取最大值而不是取和。

**如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素**。

## 内联元素的盒子

**内联元素不能设置width和height**

内联元素可以设置水平方向的内边距

内联元素可以设置垂直方向内边距，但是不会影响页面的布局

内联元素可以设置边框，但是垂直的边框不会影响到页面的布局

不会影响到页面的布局是指内联元素的高度不会撑起其他元素。

内联元素支持水平方向的外边距

内联元素不支持垂直外边距

内联元素水平方向的相邻外边距不会重叠，而是求和


## display和visibility

通过display样式可以修改元素的类型，可选值：
- inline：可以将一个元素作为内联元素显示
- block: 可以将一个元素设置块元素显示
- inline-block：将一个元素转换为行内块元素，可以使一个元素既有行内元素的特点又有块元素的特点，既可以设置宽高，又不会独占一行
- none: 不显示元素，并且元素不会在页面中继续占有位置


visibility 可以用来设置元素的隐藏和显示的状态，可选值：
- visible 默认值，元素默认会在页面显示
- hidden 元素会隐藏不显示	

使用 visibility:hidden;隐藏的元素虽然不会在页面中显示，但是它的位置会依然保持。

## overflow

子元素默认是存在于父元素的内容区中，
理论上讲子元素的最大可以等于父元素内容区大小，
如果子元素的大小超过了父元素的内容区，则超过的大小会在父元素以外的位置显示，
超出父元素的内容，我们称为溢出的内容，
父元素默认是将溢出内容，在父元素外边显示，

通过overflow可以设置父元素如何处理溢出内容：
可选值：
- visible，默认值，不会对溢出内容做处理，元素会在父元素以外的位置显示
- hidden, 溢出的内容，会被修剪，不会显示
- scroll, 会为父元素添加滚动条，通过拖动滚动条来查看完整内容，该属性不论内容是否溢出，都会添加水平和垂直双方向的滚动条
- auto，会根据需求自动添加滚动条，需要水平就添加水平，需要垂直就添加垂直，都不需要就都不加


## 文档流

文档流处在网页的最底层，它表示的是一个页面中的位置，我们所创建的元素默认都处在文档流中。
 
元素在文档流中的特点

块元素
1. 块元素在文档流中会独占一行，块元素会自上向下排列。
2. 块元素在文档流中默认宽度是父元素的100%
3. 块元素在文档流中的**高度**默认**被内容撑开**

内联元素
1. 内联元素在文档流中只占自身的大小，会默认从左向右排列，如果一行中不足以容纳所有的内联元素，则换到下一行，继续自左向右。
2. 在文档流中，内联元素的**宽度和高度**默认都**被内容撑开**

**当元素的宽度的值为auto时，此时指定内边距不会影响可见框的大小，而是会自动修改宽度，以适应内边距。**

## 浮动

块元素在文档流中默认垂直排列，所以这个三个div自上至下依次排开，
 
如果希望块元素在页面中水平排列，可以使块元素脱离文档流
 
使用float来使元素浮动，从而脱离文档流
可选值：
- none，默认值，元素默认在文档流中排列
- left，元素会立即脱离文档流，向页面的左侧浮动
- right，元素会立即脱离文档流，向页面的右侧浮动
 
当为一个元素设置浮动以后（float属性是一个非none的值），元素会立即脱离文档流，元素脱离文档流以后，它下边的元素会立即向上移动
 
元素浮动以后，会尽量向页面的左上或是右上漂浮，直到遇到父元素的边框或者其他的浮动元素

如果浮动元素上边是一个没有浮动的块元素，则浮动元素不会超过块元素

浮动的元素不会超过他上边的兄弟元素，最多最多一边齐

浮动的元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以通过浮动来设置文字环绕图片的效果

当元素设置浮动以后，会完全脱离文档流。块元素脱离文档流以后，高度和宽度都被内容撑开，相当于内联元素的特性。内联元素脱离文档流以后会变成块元素。

## 高度塌陷

在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。

但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。

由于父元素的高度塌陷了，则父元素下的所有元素都会向上移动，这样将会导致页面布局混乱。

所以在开发中一定要避免出现高度塌陷的问题，我们可以将父元素的高度写死，以避免塌陷的问题出现，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的。

1. 解决高度塌陷方案一

根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context，简称BFC，该属性可以设置打开或者关闭，默认是关闭的。

当开启元素的BFC以后，元素将会具有如下的特性：
1. 父元素的垂直外边距不会和子元素重叠	
2. 开启BFC的元素不会被浮动元素所覆盖
3. 开启BFC的元素可以包含浮动的子元素

如何开启元素的BFC
1. 设置元素浮动
- 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题
2. 设置元素绝对定位
3. 设置元素为inline-block
- 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式
4. 将元素的overflow设置为一个非visible的值
	
推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。

```css
overflow: hidden;
```

2. 解决高度塌陷方案二：

可以直接在高度塌陷的父元素的最后，添加一个空白的div，
由于这个div并没有浮动，所以他是可以撑开父元素的高度的，然后再对其进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用。

使用这种方式虽然可以解决问题，但是会在页面中添加多余的结构。

3. 解决高度塌陷方案三：

通过after伪类

可以通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加一个div的原理一样，可以达到一个相同的效果，而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用。

## 清除浮动

我们有时希望清除掉其他元素浮动对当前元素产生的影响，这时可以使用clear来完成功能。

clear可以用来清除其他浮动元素对当前元素的影响，
可选值：
- none，默认值，不清除浮动
- left，清除左侧浮动元素对当前元素的影响
- right，清除右侧浮动元素对当前元素的影响
- both，清除两侧浮动元素对当前元素的影响，清除对他影响最大的那个元素的浮动

清除浮动以后，元素会回到其他元素浮动之前的位置。